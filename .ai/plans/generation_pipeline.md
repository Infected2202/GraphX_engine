# Generation Pipeline — ExecPlan

Этот ExecPlan — **живой документ**. Поддерживайте актуальными `Progress`, `Surprises & Discoveries`, `Decision Log`, `Outcomes & Retrospective`. Стиль и структура соответствуют ExecPlans из Cookbook.

## Purpose / Big Picture

Сформировать **чистый, детерминированный** генератор расписаний, который работает как библиотека и вызывается из веб-приложения. Пайплайн использует **предыдущий календарный месяц** как контекст (вместо `prev_tail_by_emp`), поддерживает **пост-обработку сокращений смен до 8ч** (для выходных/праздников при 2+ сотрудниках на день), учитывает **производственный календарь, нормы часов, отпуска** и выдаёт матрицу ячеек + метрики + экспорт в XLSX, визуально согласованный с текущими стилями отчётов. В репозитории уже есть: выделенный слой сокращения, правки палитры для выходных/short shifts, сценарии на несколько месяцев и отпускные диапазоны — берём это как источник правды и фиксируем порядок стадий.

## Progress

* [ ] (2025-10-28) Вынесен адаптер `generate_schedule()` с чистыми входами/выходами.
* [ ] (2025-10-28) Согласованы контракты данных (cells/metrics) и схема влияния календаря.
* [ ] (2025-10-28) Слой **shortening** выполняется после нижележащих корректировок.
* [ ] (2025-10-28) Рендер XLSX из `BytesIO` с палитрой, как в текущих отчётах.
* [ ] (2025-10-28) Юнит-тесты на детерминизм/идемпотентность и кейсы сценариев (2+ месяца).

## Surprises & Discoveries

* Observation: …
  Evidence: …

## Decision Log

* **Apply order:** `Base assignment → downstream adjustments → Shortening (8h) → metrics`. Основано на коммите «Defer shortening until after downstream adjustments».
* **Context:** Всегда используем **предыдущий месяц** как контекст генерации, сценарии должны покрывать ≥2 месяцев (см. коммиты про «Ensure scenarios cover at least two months»).
* **I/O:** Никакой прямой записи на диск в генераторе; XLSX рендер возвращает `BytesIO`.
* **Visual parity:** Цвета/стили выходных и short-shift соответствуют Excel-палитре из репозитория (коммиты «Adjust Excel palette…», «Refine Excel styling…»). 

## Outcomes & Retrospective

E2E: вызов `generate_schedule(YYYY-MM)` → получаем матрицу; прогон **shortening** даёт ожидаемые M8/E8 в выходные при 2+ сотрудниках; метрики совпадают со сценарными эталонами; экспортированный XLSX визуально совпадает с текущим.

## Context and Orientation

* Репозиторий: `Infected2202/GraphX_engine` (ядро генерации, сценарии, стили Excel). В истории — вынос слоя сокращений, правки палитры, сценарии на 2+ месяцев, отпускные периоды, фиксы standalone-скриптов. Используем это как истину при проектировании интерфейсов и порядка стадий.

## Pipeline Overview (стадии и порядок)

1. **Inputs assembly**

   * `employees`: список с ключами/офисами и др. атрибутами;
   * `calendar`: типы дней (рабочий/выходной/праздник/перенос), `norm_minutes`; отпуска по сотрудникам;
   * `settings`: глобальные параметры генерации;
   * `shift_types`: легенда (ключ → визуальные токены/варианты).
     Источники — БД/JSON, но **в генератор** приходят **уже собранные структуры**.

2. **Base assignment**

   * Построение матрицы для `target_month` с учётом **контекста предыдущего месяца** (фазы, ротация, переносы), без «хвоста».
   * Результат — массив `cells` и черновые метрики.

3. **Downstream adjustments**

   * Применение ограничений календаря (праздники/переносы/нормы), отпусков и иных правок (если есть) до финальной пост-обработки.

4. **Shortening layer (8h)**

   * Применяется **после** всех корректировок (`defer … after downstream`).
   * Сокращаем *рабочие дневные смены* в **выходные/праздники** до M8/E8 **только если** в этот день дежурят **минимум 2 сотрудника** (для покрытия morning/evening).
   * Нельзя оставлять слот непокрытым; при конфликте — лог в метрики «shortening_skipped» с причиной.
   * Сохраняем office-варианты (NA/NB) и ключи.

5. **Metrics & invariants**

   * Часы/нормы по сотрудникам/офисам, счётчики сокращений/пропусков, проверки инвариантов.

6. **Render (XLSX)**

   * Преобразование в `BytesIO` со стилями, **соответствующими текущей палитре Excel** (OFF/выходные/short-shift — как в репозитории). ([GitHub][4])

## Data Contracts

```python
class Cell(TypedDict):
    emp_id: int
    day: int           # 1..days_in_month
    value: str         # 'DA'|'NB'|'OFF'|... (ключ смены)
    office: str | None # 'NA'|'NB'|... (вариант/офис)
    meta: dict         # {'class': 'cell-DA NB', ...}

class GeneratedSchedule(TypedDict):
    month: str             # 'YYYY-MM'
    days_in_month: int
    employees: list[dict]  # [{id,fio,key,office,...}]
    cells: list[Cell]
    metrics: dict          # часы/нормы/shortening_stats/…
```

**API генератора (внутренний):**

```python
def generate_schedule(month: date, *, employees, calendar, settings, shift_types) -> GeneratedSchedule: ...
def render_xlsx(schedule: GeneratedSchedule) -> io.BytesIO: ...
```

## Shortening Layer — детали

* **Условия:** день помечен как `holiday`/`weekend`; на дежурстве ≥2 сотрудников с дневной сменой;
* **Преобразование:** две дневные смены заменяются на `M8` и `E8` (или эквивалентные ключи), сохранение офисных суффиксов (`M8A/M8B`, `E8A/E8B`) если предусмотрено;
* **Приоритет:** выбираем сотрудников равномерно (распределение коротких смен по месяцу/паре), избегая перекрытия фаз;
* **Конфликты:** если после сокращения слот пуст — откат операции и счётчик `shortening_skipped += 1` (с причиной);
* **Логи метрик:** `shortening_applied`, `shortening_skipped_by_insufficient_staff`, `shortening_skipped_by_conflict`.
  Основано на вынесенном слое и уточнениях порядка в истории коммитов.

## Determinism, Idempotence & Caching

* **Детерминизм:** одинаковые входы ⇒ одинаковые `cells`/`metrics`.
* **Идемпотентность:** повторный вызов с теми же входами не меняет результат; shortening не должен «двойиться».
* **Кэш-ключ:** `ym + hash(employees) + hash(calendar) + hash(settings)` (без легенды, если она влияет только на визуал).
* **Валидации:** жёсткие проверки на «дырки» в покрытии и несоответствие нормам.

## Interfaces & Errors

* Исключения генератора → контролируемые ошибки сервиса (HTTP 400/500 в вебе), с полем `reason` и срезом входных данных (id сотрудника, день, тип дня).
* Логи: DEBUG для стадий, INFO для сводных метрик, WARN для пропусков shortening.

## Concrete Steps

1. **Adapter**

   * Создать `services/generator_adapter.py` с `generate_schedule()` и `render_xlsx()` (без файловой записи).
   * Интеграция предыдущего месяца как обязательного контекста (при отсутствии — безопасные дефолты/ошибки).

2. **Stages wiring**

   * Разделить код на `base_assignment()`, `apply_calendar()`, `apply_vacations()`, `shorten_weekend_shifts()`, `compute_metrics()`.
   * Гарантировать порядок: shortening **после** downstream-корректировок (см. коммит). 

3. **Contracts & Types**

   * Ввести TypedDict/датаклассы для `Cell/GeneratedSchedule`; унифицировать office-варианты.

4. **Rendering**

   * Вынести Excel-рендер в функцию, возвращающую `BytesIO`; привести стили к актуальной палитре (OFF/выходные/short-shift — как сейчас). 

5. **Tests**

   * Набор сценариев на 2+ месяцев, включая отпуска и праздники; снэпшоты метрик; кейсы сокращений/пропусков.

## Validation & Acceptance

* **Previous-month context:** изменение календаря предыдущего месяца влияет предсказуемо (задокументировано).
* **Shortening:** на искусственных кейсах — применён только там, где ≥2 сотрудников; нигде не «ломает» покрытие.
* **Metrics:** часы/нормы сходятся со сценарными эталонами; отчёт XLSX визуально совпадает с текущим.
* **Perf:** генерация одного месяца при типичном количестве сотрудников < N секунд (зафиксировать N после первых прогонов).

## Artifacts

* `services/generator_adapter.py`, модульные функции стадий, юнит-тесты/снэпшоты, примеры сценариев (2+ месяца), пример выгрузки XLSX и json-дампы метрик.
