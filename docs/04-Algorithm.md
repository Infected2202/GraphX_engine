**Базовый алгоритм генерации (без кода)**

## Вход

* `CONFIG.months[i]` (месяц `YYYY-MM`, месячная норма часов, отпуска — как данные, но **не применяем** их на этом этапе).
* `employees[]` (id, имя, флаги, `ytd_overtime`).
* `shift_types{}` (ключ → код, офис, длительность).
* `carry_in` (список `Assignment` на 1-е число, обычно `N8*` из прошлого месяца).

## Выход

* `schedule[date] = List[Assignment]` (на каждого сотрудника — один assignment).
* `carry_out = [Assignment(N8*, date=1-е след. месяца)]`.

---

## Шаги

### 1) Эпоха и фазы

* Эпоха ротации — **1 января** соответствующего года (`new_year_reset`).
* Для сотрудника `e` вычисляем `seed4 ∈ {0..3}` (детерминированно от `id`).
* Для даты `d`: `phase(d, e) = (seed4(e) + days_between(epoch, d)) mod 4`, где:

  * `0 → DAY`, `1 → NIGHT`, `2 → OFF`, `3 → OFF`.

### 2) Счётчик рабочих выходов до начала месяца (`work_turn_before`)

* Для каждой пары (сотрудник, месяц):

  * Идём от `epoch` до `1-го` числа месяца, считаем, сколько раз `phase ∈ {DAY, NIGHT}`.
  * Это число и есть начальный `work_turn_before[e]`, чтобы ротация офисов **не сбрасывалась** в начале месяца.

### 3) Применение `carry_in`

* Если на `1-е` уже есть `N8*` для сотрудника — **не добавляем** второй assignment в этот день.
* `N8*` — логическое продолжение ночи прошлого месяца и **не увеличивает** `work_turn_before`.

### 4) Генерация по дням месяца

Для каждой даты `d` и каждого сотрудника `e`:

* Если `carry_in` уже занял слот — пропустить.
* Вычислить `phase(d, e)`:

  * **DAY (0)**: назначить `DA`/`DB` по `turn = work_turn_before[e]` (чётный → `A`, нечётный → `B`), затем `work_turn_before[e] += 1`.
  * **NIGHT (1)**:

    * если `d` — **последний день** месяца → поставить `N4A/N4B` (по чётности), и **добавить** в `carry_out` `N8A/N8B` на `1-е` следующего месяца; затем `work_turn_before[e] += 1`;
    * иначе → `NA/NB` (по чётности), затем `work_turn_before[e] += 1`.
  * **OFF (2/3)**: `OFF`.

### 5) Лимиты часов (перерасход в месяце)

* Подсчитать фактические часы сотрудника в текущем месяце.
* Если > `норма + monthly_overtime_max` **или** приводит к превышению годового лимита:

  * Ищем дневные 12ч для этого сотрудника, **с приоритетом выходных**:

    1. заменяем на `E8*` (выходные),
    2. при необходимости — на `M8*` (будни).
* Ночные и переносы `N4/N8` **не сокращать**.

### 6) Пост-перекраска отпусков

* После генерации: для каждой даты отпуска сотрудника:

  * если будний день → `VAC8`;
  * если выходной → `VAC0`.
* Это не изменяет фазы/ротацию/переносы, влияет только на учёт часов и отчёты.

### 7) Формирование `carry_out`

* Собранные `N8*` (остатки ночи) на 1-е следующего месяца возвращаются в `carry_out`.
* Оркестратор подставит их как `carry_in` при генерации следующего месяца.

---

## Краевые случаи и решения

* **Февраль/високосный год**: `month_bounds` корректно даёт 28/29; алгоритм фаз и переносов универсален.
* **1 января**: «эпоха» = та же дата; фаза стартует от `seed4`.
* **Отпуск, пересекающий границу месяцев**: перекраска применяется по факту дат; возможна «перекраска» `N8*` в `VAC8` (это допустимо, но не должно производить «висячий перенос» — см. PR-3 синхронизацию границ).
* **Мало сотрудников (4–5)**: «соло»-дни возможны; базовый слой их не избегает — фиксируются метриками для высшего слоя.

---

## Инварианты (проверяются валидатором)

1. На дату/сотрудника — один assignment.
2. `N4*` только в последний день месяца, `N8*` только 1-го числа.
3. Фаза соответствует `phase(d, e)`; отпуск не ломает соответствие (только перекраска).
